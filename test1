SELECT
  table_name,
  ordinal_position,
  column_name,
  data_type
FROM DB_INVESTMENTS_SYST02.INFORMATION_SCHEMA.COLUMNS
WHERE table_schema = 'INVESTMENTS_SERVE'
  AND table_name IN (
    'BNK_AA_ARRANGEMENT',
    'BNK_AA_ARR_ACCOUNT',
    'BNK_AA_ARR_INTEREST',
    'BNK_AA_ARR_PAYMENT_SCHEDULE',
    'BNK_AA_INTEREST_ACCRUALS', 
    ‘BNK_CUSTOMER’,
    'BNK_AA_BILL_DETAILS'
  )
ORDER BY table_name, ordinal_position;





-- ARRANGEMENT
SELECT ARRANGEMENT_ID, ACTIVE_PRODUCT, ARR_STATUS, CUSTOMER_ROLE, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARRANGEMENT
ORDER BY MIS_DATE DESC
LIMIT 10;

-- ARR_ACCOUNT
SELECT ARRANGEMENT_KEY, ALT_ID_TYPE, ACTIVITY, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_ACCOUNT
ORDER BY MIS_DATE DESC
LIMIT 10;

-- ARR_INTEREST
SELECT ARRANGEMENT_KEY, DAY_BASIS, EFFECTIVE_RATE, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_INTEREST
ORDER BY MIS_DATE DESC
LIMIT 10;

-- PAYMENT_SCHEDULE
SELECT ARRANGEMENT_KEY, PAYMENT_TYPE, PAYMENT_METHOD, PAYMENT_FREQ, ID_COMP_3, START_DATE, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_PAYMENT_SCHEDULE
ORDER BY MIS_DATE DESC
LIMIT 10;

-- INTEREST_ACCRUALS
SELECT PROPERTY_NAME, TO_DATE, PERIOD_START, PERIOD_END, BALANCE, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_INTEREST_ACCRUALS
ORDER BY MIS_DATE DESC
LIMIT 10;

-- BILL_DETAILS
SELECT ARRANGEMENT_ID, BILL_AMOUNT, BILL_TYPE, MIS_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_BILL_DETAILS
ORDER BY MIS_DATE DESC
LIMIT 10;



-- list BLL_DETAILS columns
SELECT column_name, data_type
FROM DB_INVESTMENTS_SYST02.INFORMATION_SCHEMA.COLUMNS
WHERE table_schema = 'INVESTMENTS_SERVE'
  AND table_name = 'BNK_AA_BILL_DETAILS'
ORDER BY ordinal_position;

-- find amount
SELECT column_name, data_type
FROM DB_INVESTMENTS_SYST02.INFORMATION_SCHEMA.COLUMNS
WHERE table_schema = 'INVESTMENTS_SERVE'
  AND table_name = 'BNK_AA_BILL_DETAILS'
  AND (
    data_type ILIKE '%NUMBER%' OR
    column_name ILIKE '%AMT%' OR
    column_name ILIKE '%AMOUNT%' OR
    column_name ILIKE '%CHARGE%' OR
    column_name ILIKE '%VALUE%'
  )
ORDER BY ordinal_position;


-- 猜测候选金额列（按你的真实列名替换/扩充）
WITH ta AS (
  SELECT
    ARRANGEMENT_KEY, MIS_DATE,
    TERM_AMOUNT, COMMITMENT_AMT, AMOUNT, PRINCIPAL_AMT
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_TERM_AMOUNT
),
u AS (
  SELECT
    'TERM_AMOUNT'      AS col, COUNT_IF(TERM_AMOUNT     IS NOT NULL) AS non_null FROM ta
  UNION ALL SELECT 'COMMITMENT_AMT', COUNT_IF(COMMITMENT_AMT IS NOT NULL) FROM ta
  UNION ALL SELECT 'AMOUNT',         COUNT_IF(AMOUNT         IS NOT NULL) FROM ta
  UNION ALL SELECT 'PRINCIPAL_AMT',  COUNT_IF(PRINCIPAL_AMT  IS NOT NULL) FROM ta
)
SELECT * FROM u ORDER BY non_null DESC;

-- 所有列 & 重点筛选：金额候选列（名字或类型像金额/本金/承诺额）
SELECT column_name, data_type, ordinal_position
FROM DB_INVESTMENTS_SYST02.INFORMATION_SCHEMA.COLUMNS
WHERE table_schema = 'INVESTMENTS_SERVE'
  AND table_name   = 'BNK_AA_ARR_TERM_AMOUNT'
ORDER BY ordinal_position;


SELECT column_name, data_type
FROM DB_INVESTMENTS_SYST02.INFORMATION_SCHEMA.COLUMNS
WHERE table_schema = 'INVESTMENTS_SERVE'
  AND table_name   = 'BNK_AA_ARR_TERM_AMOUNT'
  AND (
    data_type ILIKE '%NUMBER%' OR
    column_name ILIKE '%AMT%' OR
    column_name ILIKE '%AMOUNT%' OR
    column_name ILIKE '%PRINCIPAL%' OR
    column_name ILIKE '%COMMIT%'
  )
ORDER BY column_name;



WITH t AS (
  SELECT
    ARRANGEMENT_KEY, MIS_DATE,
    AMOUNT, CHANGE_AMOUNT, COMMITMENT_DRAWDOWN, COMMITMENT_REVERSAL,
    TRANCHE_AMOUNT, COMMT_AMOUNT
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_TERM_AMOUNT
),
u AS (
  SELECT 'AMOUNT'                AS col, COUNT_IF(AMOUNT                IS NOT NULL) FROM t
  UNION ALL SELECT 'CHANGE_AMOUNT',          COUNT_IF(CHANGE_AMOUNT          IS NOT NULL) FROM t
  UNION ALL SELECT 'COMMITMENT_DRAWDOWN',    COUNT_IF(COMMITMENT_DRAWDOWN    IS NOT NULL) FROM t
  UNION ALL SELECT 'COMMITMENT_REVERSAL',    COUNT_IF(COMMITMENT_REVERSAL    IS NOT NULL) FROM t
  UNION ALL SELECT 'TRANCHE_AMOUNT',         COUNT_IF(TRANCHE_AMOUNT         IS NOT NULL) FROM t
  UNION ALL SELECT 'COMMT_AMOUNT',           COUNT_IF(COMMT_AMOUNT           IS NOT NULL) FROM t
)
SELECT * FROM u ORDER BY 2 DESC;



term_amount_latest AS (
  SELECT
    SPLIT_PART(ta.ARRANGEMENT_KEY,'-',1) AS ARRANGEMENT_ID,
    -- 主金额列：AMOUNT（TEXT → DECIMAL）
    TRY_TO_DECIMAL(REGEXP_REPLACE(ta.AMOUNT::STRING,'[^0-9\\.-]',''),38,2) AS PRINCIPAL_AMT,
    -- 事件/备注（可选）
    UPPER(COALESCE(ta.COMMITMENT_TYPE, ta.FULL_COMMITTMENT_ACTIVITY))       AS TERM_EVENT,
    COALESCE(
      TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ta.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
      ta.MIS_DATE::DATE
    ) AS ID_DATE,
    ta.MIS_DATE
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_TERM_AMOUNT ta, cob
  WHERE COALESCE(
          TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ta.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
          ta.MIS_DATE::DATE
        ) <= cob.cob_date
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY SPLIT_PART(ta.ARRANGEMENT_KEY,'-',1)
    ORDER BY COALESCE(
             TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ta.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
             ta.MIS_DATE::DATE
           ) DESC,
           ta.MIS_DATE DESC
  ) = 1
)





/* ===========================================================
   1) Expected 侧输入：INTEREST_FIELDS（每个 arrangement 一行）
   =========================================================== */

CREATE OR REPLACE VIEW DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.INTEREST_FIELDS AS
WITH
cob AS (
  SELECT MAX(COB_DAY_DATE) AS cob_date
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.V_INT_COB_DAYS
),

----link tables-----
norm AS (
  SELECT DISTINCT 'ARRANGEMENT'       AS src, a.ARRANGEMENT_ID                   AS base_id
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARRANGEMENT a
  UNION ALL
  SELECT DISTINCT 'ARR_ACCOUNT'       AS src, SPLIT_PART(aa.ARRANGEMENT_KEY,'-',1)
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_ACCOUNT aa
  UNION ALL
  SELECT DISTINCT 'ARR_INTEREST'      AS src, SPLIT_PART(ai.ARRANGEMENT_KEY,'-',1)
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_INTEREST ai
  UNION ALL
  SELECT DISTINCT 'INTEREST_ACCRUALS' AS src, REGEXP_SUBSTR(ia.PROPERTY_NAME,'AA[0-9A-Z]+')
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_INTEREST_ACCRUALS ia
  WHERE REGEXP_SUBSTR(ia.PROPERTY_NAME,'AA[0-9A-Z]+') IS NOT NULL
),
srcs AS (SELECT COUNT(DISTINCT src) AS n FROM norm),
present_in_all AS (
  SELECT base_id
  FROM norm
  GROUP BY base_id
  HAVING COUNT(DISTINCT src) = (SELECT n FROM srcs)
),

/* get arrangement before the cob*/
arrangement_latest AS (
  SELECT a.*
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARRANGEMENT a
  WHERE a.ARRANGEMENT_ID IN (SELECT base_id FROM present_in_all)
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY a.ARRANGEMENT_ID ORDER BY a.MIS_DATE DESC
  ) = 1
),

arr_account_latest AS (
  SELECT
    SPLIT_PART(aa.ARRANGEMENT_KEY,'-',1) AS ARRANGEMENT_ID,
    aa.ALT_ID_TYPE,
    aa.ACTIVITY,
    aa.MIS_DATE
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_ACCOUNT aa, cob
  WHERE TRY_TO_DATE(SPLIT_PART(SPLIT_PART(aa.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD')
          <= cob.cob_date
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY SPLIT_PART(aa.ARRANGEMENT_KEY,'-',1) ORDER BY aa.MIS_DATE DESC
  ) = 1
),

arr_interest_latest AS (
  SELECT
    SPLIT_PART(ai.ARRANGEMENT_KEY,'-',1) AS ARRANGEMENT_ID,
    ai.DAY_BASIS,
    ai.EFFECTIVE_RATE,
    COALESCE(
      TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ai.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
      ai.MIS_DATE::DATE
    ) AS ID_DATE,
    ai.MIS_DATE
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_INTEREST ai, cob
  WHERE COALESCE(
          TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ai.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
          ai.MIS_DATE::DATE
        ) <= cob.cob_date
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY SPLIT_PART(ai.ARRANGEMENT_KEY,'-',1)
    ORDER BY ID_DATE DESC, ai.MIS_DATE DESC
  ) = 1
),

-----INTEREST/INTEREST_AD_HOC---------------------
payment_schedule_latest AS (
  SELECT
    SPLIT_PART(ps.ARRANGEMENT_KEY,'-',1) AS ARRANGEMENT_ID,
    UPPER(ps.PAYMENT_TYPE)               AS PAYMENT_TYPE,
    UPPER(ps.PAYMENT_METHOD)             AS PAYMENT_METHOD,
    ps.PAYMENT_FREQ                      AS PAYMENT_FREQ_RAW,

    CASE
      WHEN REGEXP_LIKE(UPPER(ps.PAYMENT_FREQ),'E\\d+M') THEN 'M'
      WHEN REGEXP_LIKE(UPPER(ps.PAYMENT_FREQ),'E\\d+W') THEN 'W'
      WHEN REGEXP_LIKE(UPPER(ps.PAYMENT_FREQ),'E\\d+D') THEN 'D'
      WHEN REGEXP_LIKE(UPPER(ps.PAYMENT_FREQ),'E\\d+Y') THEN 'Y'
      ELSE NULL
    END AS PAYMENT_FREQ_UNIT,

    TRY_TO_NUMBER(
      COALESCE(
        REGEXP_SUBSTR(UPPER(ps.PAYMENT_FREQ), 'E(\\d+)M', 1, 1, 'e', 1),
        REGEXP_SUBSTR(UPPER(ps.PAYMENT_FREQ), 'E(\\d+)W', 1, 1, 'e', 1),
        REGEXP_SUBSTR(UPPER(ps.PAYMENT_FREQ), 'E(\\d+)D', 1, 1, 'e', 1),
        REGEXP_SUBSTR(UPPER(ps.PAYMENT_FREQ), 'E(\\d+)Y', 1, 1, 'e', 1)
      )
    ) AS PAYMENT_FREQ_NUM,
    COALESCE(
      TRY_TO_DATE(SPLIT_PART(ps.ID_COMP_3,'-',1),'YYYYMMDD'),
      ps.MIS_DATE::DATE
    ) AS ID_DATE,
    ps.START_DATE,
    ps.MIS_DATE
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_PAYMENT_SCHEDULE ps, cob
  WHERE UPPER(ps.PAYMENT_TYPE) LIKE 'INTEREST%'
    AND COALESCE(
          TRY_TO_DATE(SPLIT_PART(ps.ID_COMP_3,'-',1),'YYYYMMDD'),
          ps.MIS_DATE::DATE
        ) <= cob.cob_date
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY SPLIT_PART(ps.ARRANGEMENT_KEY,'-',1)
    ORDER BY ID_DATE DESC, ps.MIS_DATE DESC
  ) = 1
),

------ARR_TERM_AMOUNT AMOUNT（TEXT→DECIMAL）-------
term_amount_latest AS (
  SELECT
    SPLIT_PART(ta.ARRANGEMENT_KEY,'-',1) AS ARRANGEMENT_ID,
    TRY_TO_DECIMAL(REGEXP_REPLACE(ta.AMOUNT::STRING,'[^0-9\\.-]',''),38,2) AS PRINCIPAL_AMT,
    UPPER(COALESCE(ta.COMMITMENT_TYPE, ta.FULL_COMMITTMENT_ACTIVITY)) AS TERM_EVENT,
    COALESCE(
      TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ta.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
      ta.MIS_DATE::DATE
    ) AS ID_DATE,
    ta.MIS_DATE
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_ARR_TERM_AMOUNT ta, cob
  WHERE COALESCE(
          TRY_TO_DATE(SPLIT_PART(SPLIT_PART(ta.ARRANGEMENT_KEY,'-',3),'.',1),'YYYYMMDD'),
          ta.MIS_DATE::DATE
        ) <= cob.cob_date
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY SPLIT_PART(ta.ARRANGEMENT_KEY,'-',1)
    ORDER BY ID_DATE DESC, ta.MIS_DATE DESC
  ) = 1
),

------break details------------------------------------
break_details_latest AS (
  SELECT
    b.ARRANGEMENT_ID,
    COALESCE(UPPER(b.BREAK_CANCELLED),'NO') AS BREAK_CANCELLED,
    UPPER(b.BRK_REASON)                     AS BRK_REASON
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_BNZ_BREAK_DETAILS b
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY b.ARRANGEMENT_ID ORDER BY b.MIS_DATE DESC
  ) = 1
)

------select from all tables------
SELECT
  a.ARRANGEMENT_ID,
  a.ACTIVE_PRODUCT,
  a.ARR_STATUS,
  a.CUSTOMER_ROLE,

  ai.DAY_BASIS,
  ai.EFFECTIVE_RATE,

  ps.PAYMENT_TYPE,
  ps.PAYMENT_METHOD,
  COALESCE(ps.PAYMENT_FREQ_UNIT, ps.PAYMENT_FREQ_RAW) AS PAYMENT_FREQ,
  ps.PAYMENT_FREQ_NUM,

  ta.PRINCIPAL_AMT,
  ta.TERM_EVENT,

  CASE
    WHEN UPPER(ps.PAYMENT_METHOD) LIKE 'CAPITALIS%' THEN 'ROLLOVER'
    WHEN UPPER(ps.PAYMENT_FREQ_UNIT) = 'M'
         AND UPPER(TO_VARCHAR(ps.START_DATE)) = 'R_RENEWAL' THEN 'ROLLOVER_MATURITY'
    ELSE 'PAY_AT_MATURITY'
  END AS PAYMENT_ADJUSTED,

  bd.BREAK_CANCELLED,
  bd.BRK_REASON
FROM arrangement_latest a
LEFT JOIN arr_account_latest      aa USING (ARRANGEMENT_ID)
LEFT JOIN arr_interest_latest     ai USING (ARRANGEMENT_ID)
LEFT JOIN payment_schedule_latest ps USING (ARRANGEMENT_ID)
LEFT JOIN term_amount_latest      ta USING (ARRANGEMENT_ID)
LEFT JOIN break_details_latest    bd USING (ARRANGEMENT_ID)
;

/* ===========================================================
   2) Actual-INTEREST_ACCRUALS_FLAT
   =========================================================== */
CREATE OR REPLACE VIEW DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.INTEREST_ACCRUALS_FLAT AS
WITH cob AS (
  SELECT MAX(COB_DAY_DATE) AS cob_date
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.V_INT_COB_DAYS
)
SELECT
  REGEXP_SUBSTR(ia.PROPERTY_NAME,'AA[0-9A-Z]+') AS ARRANGEMENT_ID,
  TRY_TO_DATE(f.value::STRING,'YYYYMMDD')       AS TO_DATE,
  TRY_TO_DATE(SPLIT(ia.PERIOD_START, HEX_DECODE_STRING('EFA3BD'))[f.index]::STRING,'YYYYMMDD') AS PERIOD_START,
  TRY_TO_DATE(SPLIT(ia.PERIOD_END,   HEX_DECODE_STRING('EFA3BD'))[f.index]::STRING,'YYYYMMDD') AS PERIOD_END,
  TRY_TO_DECIMAL(SPLIT(ia.BALANCE,   HEX_DECODE_STRING('EFA3BD'))[f.index]::STRING,38,2)       AS BALANCE,
  (SELECT cob_date FROM cob) AS CURRENT_COB_DATE
FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_INTEREST_ACCRUALS ia,
     LATERAL FLATTEN(input => SPLIT(ia.TO_DATE, HEX_DECODE_STRING('EFA3BD'))) f
WHERE REGEXP_SUBSTR(ia.PROPERTY_NAME,'AA[0-9A-Z]+') IS NOT NULL
  AND TRY_TO_DATE(f.value::STRING,'YYYYMMDD') <= (SELECT cob_date FROM cob)
;

/* ===========================================================
   3) Actual-BILL_DETAILS_INTEREST
   =========================================================== */
CREATE OR REPLACE VIEW DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BILL_DETAILS_INTEREST AS
WITH src AS (
  SELECT
    ARRANGEMENT_ID,
    UPPER(BILL_TYPE) AS BILL_TYPE,
    MIS_DATE,
    TRY_TO_DECIMAL(REGEXP_REPLACE(PAYMENT_AMOUNT::STRING,'[^0-9\\.-]',''),38,2)  AS PAYMENT_AMOUNT_N,
    TRY_TO_DECIMAL(REGEXP_REPLACE(PAYMENT_AMT_REC::STRING,'[^0-9\\.-]',''),38,2) AS PAYMENT_AMT_REC_N,
    TRY_TO_DECIMAL(REGEXP_REPLACE(REPAY_AMOUNT::STRING,'[^0-9\\.-]',''),38,2)    AS REPAY_AMOUNT_N,
    TRY_TO_DECIMAL(REGEXP_REPLACE(ADJUST_AMT::STRING,'[^0-9\\.-]',''),38,2)      AS ADJUST_AMT_N,
    TRY_TO_DECIMAL(REGEXP_REPLACE(WRITEOFF_AMT::STRING,'[^0-9\\.-]',''),38,2)    AS WRITEOFF_AMT_N,
    TRY_TO_DECIMAL(REGEXP_REPLACE(CHARGEOFF_AMOUNT::STRING,'[^0-9\\.-]',''),38,2)AS CHARGEOFF_AMOUNT_N
  FROM DB_INVESTMENTS_SYST02.INVESTMENTS_SERVE.BNK_AA_BILL_DETAILS
  WHERE UPPER(BILL_TYPE) LIKE '%INTEREST%'
),
pick AS (
  SELECT
    ARRANGEMENT_ID,
    BILL_TYPE,
    MIS_DATE,
    COALESCE(
      PAYMENT_AMOUNT_N,
      PAYMENT_AMT_REC_N,
      REPAY_AMOUNT_N,
      ADJUST_AMT_N,
      WRITEOFF_AMT_N,
      CHARGEOFF_AMOUNT_N
    ) AS ACTUAL_INTEREST_AMT,
    CASE
      WHEN PAYMENT_AMOUNT_N   IS NOT NULL THEN 'PAYMENT_AMOUNT'
      WHEN PAYMENT_AMT_REC_N  IS NOT NULL THEN 'PAYMENT_AMT_REC'
      WHEN REPAY_AMOUNT_N     IS NOT NULL THEN 'REPAY_AMOUNT'
      WHEN ADJUST_AMT_N       IS NOT NULL THEN 'ADJUST_AMT'
      WHEN WRITEOFF_AMT_N     IS NOT NULL THEN 'WRITEOFF_AMT'
      WHEN CHARGEOFF_AMOUNT_N IS NOT NULL THEN 'CHARGEOFF_AMOUNT'
      ELSE 'N/A'
    END AS AMOUNT_SOURCE
  FROM src
)
SELECT *
FROM pick
WHERE ACTUAL_INTEREST_AMT IS NOT NULL
;



